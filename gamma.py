# from: https://github.com/raplin/HexaWS2811/blob/master/gamma.py
# Adapted by gregfriedland 8/14/2015 to do use the 'standard' gamma exponent function
# and to work with different bitdepths.
#
#
# Lookup table generator
#
# Really it's correcting for the eye's luminance response, it's not actually gamma correction (it's misnamed!)
#
# We're generating a set of 256-entry lookup tables which you use to (separately) convert the 8-bit R, G and B components of your color
# into something you output, typically with an intelligent RGB LED such as a WS2812B; but a simple CPU-based PWM will give the same results (and benefit from this correction)
# 
# We generate several sets  (2,4,8...) of 256-entry tables so you can cycle through them, using a successive 8-bit lookup table each successive output frame.
# This is 'temporal dithering', which aims to give you better color resolution at the dark end of the scale.
# If you update at e.g. 100hz, try using two or three 'ditherBits' (i.e. 2^^2 or 2^^3=8 tables. The faster your update the more tables you can use
# and you get better color resolution. More than 5 ditherbits is probably excessive, even 2 will help somewhat.
#
# If you get objectionable flickering when displaying low-intensity pixels, you should either update your leds faster or reduce ditherBits
# 
# 
#
fout=open("gamma.h","wt")

#adjust me! Each extra bit doubles the table size 
ditherBits=3

# the gamma value
gamma = 2.5

# set to 8 or 16 for 8bit or 16bit table values
bitdepth = 16

maxval = 2**bitdepth-1
ditherMSB=1<<(ditherBits-1)

res="""/* Dithered luminance correction table - autogenerated by gamma.py */
#ifndef GAMMA_H
#define GAMMA_H

#include <stdint.h>

#define DITHER_BITS %d

const uint%d_t  gammaTable[] = {
""" % (ditherBits, bitdepth)

for dither in range(1<<ditherBits):
    out=[]

    #reverse the low order bits so the dithering is less flickery
    ditherValue=0
    dread=1<<ditherBits
    dout=1
    for d in range(ditherBits):
        dread>>=1
        if dither & dread:
            ditherValue|=dout
        dout<<=1;
    
    ditherValue=(ditherValue<<(8-ditherBits))

    for n in range(256):
        pwmValue = pow(float(n) / float(256), gamma)
        pwmValue=int(pwmValue * maxval + 0.5)
        pwmValue+=ditherValue
        out.append( pwmValue )
    if dither:
        res+=","
    res+="\n\t"+(",".join([ "0x%x"%n for n in out]))  
    
res+="""
};

// gamma table lookup; ditherCycle should be incremented after every
// lookup or group (e.g. RGB) of lookups
uint%d_t gamma(uint8_t n, int ditherCycle) {
    int ditherFrame = ditherCycle & ((1<<DITHER_BITS)-1);
    return gammaTable[(ditherFrame<<8) + n];
}

#endif""" % (bitdepth)

print >> fout,res
fout.close()
